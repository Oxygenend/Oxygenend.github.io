<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>超级简历的一面.</title>
      <link href="2021/03/26/%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8E%86%E4%B8%80%E9%9D%A2/"/>
      <url>2021/03/26/%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8E%86%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="找到数组中符合条件的数"><a href="#找到数组中符合条件的数" class="headerlink" title="找到数组中符合条件的数"></a>找到数组中符合条件的数</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var newArray &#x3D; &#123;&#125;;</span><br><span class="line">var array &#x3D;[</span><br><span class="line">&#123;name:&#39;aiai&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;sisi&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;lulu&#39;,aeg:12&#125;</span><br><span class="line">]</span><br><span class="line">newArray &#x3D; this.array.find((item)&#x3D;&gt;&#123;</span><br><span class="line">if(item.name&#x3D;&#x3D;&#x3D;&#39;sisi&#39;)&#123;</span><br><span class="line">return item</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findIndex&#96;方法的用法与&#96;find&#96;方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回&#96;-1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].findIndex(function(value,index,arr)&#123;</span><br><span class="line">return value&gt;2;</span><br><span class="line">&#125;)   &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure><h4 id="for循环-加if判断"><a href="#for循环-加if判断" class="headerlink" title="for循环 加if判断"></a>for循环 加if判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var newArray &#x3D; [];</span><br><span class="line">var j &#x3D; 0;</span><br><span class="line">var array &#x3D;[</span><br><span class="line">&#123;name:&#39;aiai&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;sisi&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;lulu&#39;,aeg:12&#125;</span><br><span class="line">]</span><br><span class="line">for (let i in array)&#123;</span><br><span class="line">if(array[i].name&#x3D;&#x3D;&#x3D;&#39;sisi&#39;)&#123;</span><br><span class="line">newArray[j++]&#x3D;array[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array &#x3D;[</span><br><span class="line">&#123;name:&#39;aiai&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;sisi&#39;,aeg:12&#125;,</span><br><span class="line">&#123;name:&#39;lulu&#39;,aeg:12&#125;</span><br><span class="line">]</span><br><span class="line">function filterByName(array,name)&#123;</span><br><span class="line">return array.filter(item&#x3D;&gt;item.name&#x3D;&#x3D;&#x3D;name)</span><br><span class="line">&#125;</span><br><span class="line">console.log(filterByName(array,&#39;sisi&#39;))</span><br></pre></td></tr></table></figure><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p><code>includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].includes(2)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (arr.indexOf(el) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历数组的方法"><a href="#遍历数组的方法" class="headerlink" title="遍历数组的方法"></a>遍历数组的方法</h3><p>使用<code>for</code>和<code>for/in</code>，我们可以访问数组的下标，而不是实际的数组元素值箭头函数与普通函数的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(let i&#x3D;0;i&gt;arr.length;i++)&#123;</span><br><span class="line">console.log(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let i in arr)&#123;</span><br><span class="line">console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for/of 可以直接访问数组的元素值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const v of arr)&#123;</span><br><span class="line">console.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>forEach()</code>，则可以同时访问数组的下标与元素值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach((v,i)&#x3D;&gt;console.log(v))</span><br></pre></td></tr></table></figure><p>map方法 让数组通过某种计算产生一个新数组,影射成一个新的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3]</span><br><span class="line">var firearr &#x3D; arr.map(current &#x3D;&gt; current * 5)</span><br><span class="line">console.log(firearr); &#x2F;&#x2F;[ 5, 10, 15 ]</span><br></pre></td></tr></table></figure><p>filter方法 筛选出过滤出数组中符合条件的项,组成新数组.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 4, 5, 6]</span><br><span class="line">var morearr &#x3D; arr.filter(function(number) &#123;</span><br><span class="line">    return number &gt; 3</span><br><span class="line">&#125;)</span><br><span class="line">console.log(morearr);&#x2F;&#x2F;[ 4, 5, 6 ]</span><br></pre></td></tr></table></figure><h4 id="箭头函数基本语法"><a href="#箭头函数基本语法" class="headerlink" title="箭头函数基本语法"></a>箭头函数基本语法</h4><ul><li>如果箭头函数没有参数，直接写一个空括号即可</li><li>如果参数只有一个可以省略参数的括号</li><li>如果有多个参数写在括号里用都好分割</li><li>如果函数体只有一句代码或一个变量或简单的js表达式，可以省去函数体的大括号</li><li>如果只有一条语句不需要返回值，可以在这条语句前加一个viod关键字</li><li>箭头函数最常见的用处就是简化回调函数</li></ul><h4 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h4><ul><li>语法更加简洁、清晰</li><li>箭头函数不会创建自己的this,它会捕获自己在定义时所处的外层执行环境的this,并且继承这个this值。所以箭头函数中的this的指向在它定义时就已经确定了，永远不会改变。</li><li>call()/apply()/bind()也无法改变箭头函数中this的指向</li><li>箭头函数不能作为构造函数使用</li><li>箭头函数没有原型prototype</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><p>实例初始化之后，数据观测和事件配置之前被调用（此时data 和 methods 以及页面的DOM结构都没有初始化 什么都做不了）</p><h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><p>实例完成创建之后被立即调用（此时data 和 methods已经可以使用 但是页面还没有渲染出来）调用后台数据</p><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><p>在挂载之前被调用(此时页面上还看不到真实数据 只是一个模板页面而已)</p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>el被新创建的vm.$el替换，并挂载到实例上去之后调用改钩子（ 数据已经真实渲染到页面上 在这个钩子函数里面我们可以使用一些第三方的插件） 修改switch开关的颜色 兄弟组件传值接收方监听事件</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>数据更新时调用，发生在虚拟DOM打补丁之前（ 页面上数据还是旧的）</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><p>由于数据更新导致的虚拟DOM重新渲染和打补丁，在这之后会调用改钩子（页面上的数据已经替换成最新的了）</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>实例销毁之前调用</p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h4><p>实例销毁之后调用</p><h3 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h3><ol><li>兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据 提供事件中心 var hub = new Vue()</li><li>传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)</li><li>接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名</li><li>销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据</li></ol><h3 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h3><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><p>父组件发送的形式是以属性的形式绑定值在子组件的身上</p><p>子组件用属性props接收</p><h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4><p>$emit()参数一为自定义事件名，参数二是需要传递的数据</p><p>父组件用v-on监听子组件的事件</p><h3 id="npm、cnpm、yarn-的区别"><a href="#npm、cnpm、yarn-的区别" class="headerlink" title="npm、cnpm、yarn 的区别"></a>npm、cnpm、yarn 的区别</h3><h5 id="yarn的优点"><a href="#yarn的优点" class="headerlink" title="yarn的优点"></a>yarn的优点</h5><ul><li>速度快：并行安装、离线模式</li><li>安装版本统一</li><li>更简洁的输出</li><li>多注册来源处理</li></ul><h5 id="Yarn和npm命令对比"><a href="#Yarn和npm命令对比" class="headerlink" title="Yarn和npm命令对比"></a>Yarn和npm命令对比</h5><table><thead><tr><th align="left">npm</th><th align="left">yarn</th></tr></thead><tbody><tr><td align="left">npm install</td><td align="left">yarn</td></tr><tr><td align="left">npm install react –save</td><td align="left">yarn add react</td></tr><tr><td align="left">npm uninstall react –save</td><td align="left">yarn remove react</td></tr><tr><td align="left">npm install react –save-dev</td><td align="left">yarn add react –dev</td></tr><tr><td align="left">npm update –save</td><td align="left">yarn upgrade</td></tr></tbody></table><h3 id="const、var、let区别，const定义对象，可以改变对象的属性嘛"><a href="#const、var、let区别，const定义对象，可以改变对象的属性嘛" class="headerlink" title="const、var、let区别，const定义对象，可以改变对象的属性嘛"></a>const、var、let区别，const定义对象，可以改变对象的属性嘛</h3><p>…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>捡垃圾系列之-Olympus奥林巴斯相机</title>
      <link href="2021/03/26/%E6%8D%A1%E5%9E%83%E5%9C%BE%E7%B3%BB%E5%88%97%E4%B9%8B-Olympus%E5%A5%A5%E6%9E%97%E5%B7%B4%E6%96%AF%E7%9B%B8%E6%9C%BA/"/>
      <url>2021/03/26/%E6%8D%A1%E5%9E%83%E5%9C%BE%E7%B3%BB%E5%88%97%E4%B9%8B-Olympus%E5%A5%A5%E6%9E%97%E5%B7%B4%E6%96%AF%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是ccd卡片机？"><a href="#什么是ccd卡片机？" class="headerlink" title="什么是ccd卡片机？"></a>什么是ccd卡片机？</h4><p>CCD，英文全称：Charge coupled Device， 中文全称：电荷耦合元件，可以称为CCD图像传感器。 CCD是一种半导体器件，能够把光学影像转化为数字信号。 CCD技术发展较早，比较成熟，在隔离噪声，成像质量上相对CMOS光电传感器有一定优势。但无论是哪一种，我全都要，好吧。</p><p><img src="https://7.dusays.com/2020/11/21/105d3aee39c53.gif" alt="img"></p><h4 id="关于我购买的“奥林巴斯X775”"><a href="#关于我购买的“奥林巴斯X775”" class="headerlink" title="关于我购买的“奥林巴斯X775”"></a>关于我购买的“奥林巴斯X775”</h4><p>在小红书上偶然种草的，其余还有很多优秀的<code>ccd相机</code>， 但我一眼就相中了这款<code>奥林巴斯X775</code>，是古董机，卡片机，面包机。拍出来真的被惊艳了， 拍出来就很有复古胶片感。希望接下来能好好拍照吧。敬请期待我的古董机相册。</p><ul><li><p>相机外观一览</p><p><img src="https://7.dusays.com/2020/11/24/6772ba8558311.jpg" alt="img"></p><p><img src="https://7.dusays.com/2020/11/24/c90f3ac9bb9b0.jpg" alt="img"></p><p><img src="https://7.dusays.com/2020/11/24/14104addf3f07.jpg" alt="img"></p></li><li><p>中文名 奥林巴斯X-775</p></li><li><p>上市时间 2007</p></li><li><p>有效像素 710万像素</p></li><li><p>数码变焦 4倍</p></li><li><p>传感器类型 CCD</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于ES6</title>
      <link href="2021/03/26/%E5%85%B3%E4%BA%8EES6/"/>
      <url>2021/03/26/%E5%85%B3%E4%BA%8EES6/</url>
      
        <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p><p>let在<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i &#x3D; &#39;abc&#39;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; abc</span><br><span class="line">&#x2F;&#x2F; abc</span><br><span class="line">&#x2F;&#x2F; abc</span><br></pre></td></tr></table></figure><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</p><p>有些“死区”比较隐蔽，不太容易发现。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>暂时性死区的本质就是，<strong>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><ul><li>第一种场景，内层变量可能会覆盖外层变量。</li><li>第二种场景，用来计数的循环变量泄露为全局变量。</li></ul><ol><li><code>let</code>实际上为 JavaScript 新增了块级作用域。</li><li>ES6 允许块级作用域的任意嵌套。</li><li>内层作用域可以定义外层作用域的同名变量。</li><li>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</li><li>避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</li><li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li></ol><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><ol><li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。所以对于<code>const</code>来说，只声明不赋值，就会报错。</li><li><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</li><li><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li><li><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</li><li>对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</li><li>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</li></ol><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li><code>var</code>命令和<code>function</code>命令</li><li><code>let</code>和<code>const</code></li><li><code>import</code>命令和<code>class</code></li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><ol><li>如果解构不成功，变量的值就等于<code>undefined</code>。</li><li>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功</li><li>如果等号的右边不是数组，那么将会报错。</li><li>对于 Set 结构，也可以使用数组的解构赋值。</li></ol><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><ol><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</li></ol><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><ul><li>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</li></ul><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li></ul><p>如果变量名与属性名不一致，必须写成下面这样。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br><span class="line"><span class="comment">//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</li></ul><p>可以嵌套赋值</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值可以取到继承的属性</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code></p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h3><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><h3 id="变量的解构赋值用途"><a href="#变量的解构赋值用途" class="headerlink" title="变量的解构赋值用途"></a>变量的解构赋值用途</h3><p>（1）交换变量的值</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>（2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unction <span class="function"><span class="title">example</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br></pre></td></tr></table></figure><p>（3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><p>（4）提取 JSON 数据</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p>（5）函数参数的默认值</p><p>（6）遍历 Map 结构</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>（7）输入模块的指定方法</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><p>模板字符串之中还能调用函数。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“<strong>标签模板</strong>”功能</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert([<span class="string">&#x27;hello&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h2><ol><li>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。<code>fromCodePoint</code>方法定义在<code>String</code>对象上</li><li>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</li><li><code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</li><li>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li><li>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</li></ol><ul><li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p></li><li><p>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li><li><p>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p></li></ul><ol><li><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</li><li>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</li></ol><ul><li><code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</li><li><code>padStart()</code>的常见用途是为数值补全指定位数，另一个用途是提示字符串格式。</li></ul><ol><li><a href="https://github.com/tc39/proposal-string-left-right-trim">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li></ol><ul><li>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</li></ul><h3 id="数字的扩展"><a href="#数字的扩展" class="headerlink" title="数字的扩展"></a>数字的扩展</h3><ol><li>传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效</li></ol><ul><li><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</li><li><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</li></ul><ol><li><p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p></li><li><p><code>Number.isInteger()</code>用来判断一个数值是否为整数。<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</p></li><li><p><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的</p><p>比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内</p></li><li><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p></li><li><p>ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p><p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code></p><p>BigInt 与普通整数是两种值，它们之间并不相等。</p><p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p><p><code>BigInt()</code>构造函数必须有参数，而且参数必须可以正常转为数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInt(&#39;123&#39;) &#x2F;&#x2F; 123n</span><br><span class="line">BigInt(false) &#x2F;&#x2F; 0n</span><br></pre></td></tr></table></figure><p>BigInt 不能与普通数值进行混合运算</p></li></ol><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><ul><li><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p></li><li><p>使用参数默认值时，函数不能有同名参数。</p></li><li><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p></li><li><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></span><br></pre></td></tr></table></figure></li><li><p>函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p></li></ul><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的<code>length</code>属性，不包括 rest 参数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</li></ul><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">&#x27; &#x27;</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>箭头函数有几个使用注意点。</strong></p><ol><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。(<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。)</li><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li></ol><h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><h5 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h5><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。修改一个会时另一个也更改</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5方法</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();<span class="comment">//a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</span></span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6复制数组写法</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><h5 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h5><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两种方法都是浅拷贝，使用的时候需要注意。</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><h5 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h5><p>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).filter(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.textContent.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</li><li><code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换</li></ol><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。除了属性简写，方法也可以简写</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，简写的对象方法不能用作构造函数，会报错。</p><p>表达式作为属性名，这时要将表达式放在方括号之内。表达式还可以用于定义方法名。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><ol><li>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</li><li><code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</li><li>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</li></ol><p>有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>ES6 一共有 5 种方法可以<strong>遍历对象的属性</strong>。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>ES6 又新增了另一个类似的**关键字<code>super</code>**，指向当前对象的原型对象。</p><p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><p><a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><p>重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除字符串里面的重复字符</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Set 结构的实例有以下属性</strong></p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p><strong>Set 实例的方法：操作方法（用于操作数据）</strong></p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p><strong>Set 结构的实例遍历方法，可以用于遍历成员</strong></p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。</li></ul><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><p><strong><code>WeakMap</code>与<code>Map</code>的区别有两点。</strong></p><p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类型和语法</title>
      <link href="2021/03/26/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/"/>
      <url>2021/03/26/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h1><blockquote><ol><li>JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。</li><li>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</li><li>很多开发人员将undeﬁned 和 undeclared 混为一谈，但在JavaScript 中它们是两码事。 undefined 是值的一种。undeclared 则表示变量还没有被声明过。</li><li>遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问”undeclared” 变量时这样报 错：ReferenceError: a is not deﬁned，并且typeof 对 undeﬁned 和 undeclared 变量都返回 “undefined”。</li><li>然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的 办法。</li></ol></blockquote><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p><strong>JavaScript七种内置类型</strong></p><ul><li>空值（null）</li><li>未定义（undefined）</li><li>布尔值（ boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>对象（object）</li><li>符号（symbol，ES6 中新增）</li></ul><p>除对象之外，其他统称为“基本类型”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     &#x3D;&#x3D;&#x3D; &quot;undefined&quot;; &#x2F;&#x2F; true </span><br><span class="line">typeof true          &#x3D;&#x3D;&#x3D; &quot;boolean&quot;;   &#x2F;&#x2F; true</span><br><span class="line">typeof 42            &#x3D;&#x3D;&#x3D; &quot;number&quot;;    &#x2F;&#x2F; true</span><br><span class="line">typeof &quot;42&quot;          &#x3D;&#x3D;&#x3D; &quot;string&quot;;    &#x2F;&#x2F; true </span><br><span class="line">typeof &#123; life: 42 &#125;  &#x3D;&#x3D;&#x3D; &quot;object&quot;;    &#x2F;&#x2F; true </span><br><span class="line">typeof Symbol()      &#x3D;&#x3D;&#x3D; &quot;symbol&quot;;    &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">typeof null          &#x3D;&#x3D;&#x3D; &quot;object&quot;;    &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;null 是基本类型中唯一的一个“假值，正确的返回结果应该是 &quot;null&quot;，但这个bug 由来已久</span><br><span class="line"></span><br><span class="line">typeof function a()&#123; &#x2F;* .. *&#x2F; &#125; &#x3D;&#x3D;&#x3D; &quot;function&quot;; &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;函数是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属 性 [[Call]]，该属性使其可以被调用。</span><br><span class="line"></span><br><span class="line">typeof [1,2,3] &#x3D;&#x3D;&#x3D; &quot;object&quot;; &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;数组也是对象。确切地说，它也是 object 的一个“子类型”，数组的 元素按数字顺序来进行索</span><br></pre></td></tr></table></figure><h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><ul><li>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。</li><li>也就是说JavaScript 不做“类型强制”；也就是说，语言引擎不要求变量总是 持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为 数字类型值。</li><li>所以在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类 型，因为 JavaScript 中的变量没有类型</li></ul><h3 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h3><ol><li>已在作用域中声明但还没有赋值的变量，是 undeﬁned 的。</li><li>相反，还没有在作用域中声明 过的变量，是 undeclared 的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a; </span><br><span class="line"> typeof a; &#x2F;&#x2F; &quot;undefined&quot; </span><br><span class="line"> typeof b; &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;对于 undeclared（或者 not deﬁned）变量，typeof 照样返回 &quot;undefined&quot;。请注意虽然 b 是 一个 undeclared 变量，但 typeof b 并没有报错。这是因为 typeof 有一个特殊的安全防范 机制。</span><br></pre></td></tr></table></figure><h1 id="2-值"><a href="#2-值" class="headerlink" title="2.值"></a>2.值</h1><blockquote><ol><li>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的 行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整 数”和“浮点型”。</li><li>基本类型中定义了几个特殊的值。<br>null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之 前默认值都是 undefined。void 运算符返回 undefined。</li><li>数 字 类 型 有 几 个 特 殊 值， 包 括NaN（ 意 指“not a number”， 更 确 切 地 说 是“invalid number”）、 +Infinity、-Infinity 和 -0。</li><li>简单标量基本类型值（字符串和数字等）通过值复制来赋值 / 传递，而复合值（对象等） 通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不 能指向别的变量 / 引用，只能指向值。</li></ol></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、 数字、对象（object），甚至是其他数组（多维数组）</li><li>对数组声明后即可向其中加入值，不需要预先设定大小</li></ol><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分 类似。另一个例子是通过 arguments 对象（类数组）将函数的参数当作列表来访问（从 ES6 开始已废止）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;    </span><br><span class="line">    var arr &#x3D; Array.prototype.slice.call( arguments );    </span><br><span class="line">    arr.push( &quot;bam&quot; );  </span><br><span class="line">    console.log( arr ); </span><br><span class="line">&#125; </span><br><span class="line">foo( &quot;bar&quot;, &quot;baz&quot; ); &#x2F;&#x2F; [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span><br><span class="line">&#x2F;&#x2F;工具函数 slice(..) 经常被用于这类转换，slice() 返回参数列表（上例中是一个类数组）的一个数组复本。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用 ES6 中的内置工具函数 Array.from(..) 也能实现同样的功能：</span><br><span class="line">var arr &#x3D; Array.from( arguments ); </span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>字符串和数组很相似，它是类数组，都有 length 属性以及 indexOf(..)（从 ES5 开始数组支持此方法）和 concat(..) 方法</li><li>JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符 串。而数组的成员函数都是在其原始值上进行操作。</li><li>许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数 组的非变更方法来处理字符串</li><li>另一个不同点在于字符串反转（JavaScript 面试常见问题）。数组有一个字符串没有的可变<br>更成员函数 reverse()。我们无法“借用”数组的可变更成员函数，因为字符串是不可变的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;字符串反转一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串</span><br><span class="line">var c &#x3D; a      </span><br><span class="line">    .split( &quot;&quot; )      &#x2F;&#x2F; 将a的值转换为字符数组    </span><br><span class="line">    .reverse()       &#x2F;&#x2F; 将数组中的字符进行倒转   </span><br><span class="line">    .join( &quot;&quot; );    &#x2F;&#x2F; 将数组中的字符拼接回字符串   </span><br><span class="line"></span><br><span class="line">c; &#x2F;&#x2F; &quot;oof&quot;</span><br></pre></td></tr></table></figure><ol><li>如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在 字符串和数组之间来回折腾。可以在需要时使用 join(“”) 将字符数组转换为字符串</li></ol><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ol><li>JavaScript 只有一种数值类型：number（数字），包括“整数”和带小数的十进制数。此处 “整数”之所以加引号是因为和其他语言不同，JavaScript 没有真正意义上的整数</li><li>JavaScript 中的“整数”就是没有小数的十进制数。所以 42.0 即等同于“整数”42。</li></ol><h3 id="数字语法"><a href="#数字语法" class="headerlink" title="数字语法"></a>数字语法</h3><p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a;                  &#x2F;&#x2F; 50000000000 </span><br><span class="line">a.toExponential();  &#x2F;&#x2F; &quot;5e+10&quot; </span><br></pre></td></tr></table></figure><p>tofixed(..) 方法可指定小数部分的显示位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42.59; </span><br><span class="line">a.toFixed( 0 ); &#x2F;&#x2F; &quot;43&quot; </span><br><span class="line">a.toFixed( 4 ); &#x2F;&#x2F; &quot;42.5900&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">42.toFixed( 3 );    &#x2F;&#x2F; SyntaxError 无效语法</span><br><span class="line">42 .toFixed(3); &#x2F;&#x2F; &quot;42.000&quot; 空格有效</span><br><span class="line">42..toFixed( 3 );   &#x2F;&#x2F; &quot;42.000&quot;  </span><br><span class="line">&#x2F;&#x2F;第一个 . 被视为 number 的一部分，第二个 . 是属性访问 运算符</span><br></pre></td></tr></table></figure><p>toPrecision(..) 方法用来指定有效数位的显示位数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42.59; </span><br><span class="line">a.toPrecision( 1 ); &#x2F;&#x2F; &quot;4e+1&quot;</span><br><span class="line">a.toPrecision( 2 ); &#x2F;&#x2F; &quot;43&quot;</span><br><span class="line">a.toPrecision( 3 ); &#x2F;&#x2F; &quot;42.6&quot;</span><br></pre></td></tr></table></figure><h3 id="较小数值"><a href="#较小数值" class="headerlink" title="较小数值"></a>较小数值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3; &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F;二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。</span><br></pre></td></tr></table></figure><p><strong>如何做到完全精确</strong></p><p>也就是怎样来判断 0.1 + 0.2 和 0.3 是否相等？</p><p>最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon）， 对 JavaScript 的数字来说，这个值通常是 2^-52</p><ol><li>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用</li><li>为 ES6 之前 的版本写 polyﬁll：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!Number.EPSILON) &#123;  </span><br><span class="line">    Number.EPSILON &#x3D; Math.pow(2,-52);    </span><br><span class="line">&#125;</span><br><span class="line">可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）：</span><br><span class="line">function numbersCloseEnoughToEqual(n1,n2) &#123;   </span><br><span class="line">    return Math.abs( n1 - n2 ) &lt; Number.EPSILON; </span><br><span class="line">&#125; </span><br><span class="line"> var a &#x3D; 0.1 + 0.2;</span><br><span class="line"> var b &#x3D; 0.3; </span><br><span class="line"> numbersCloseEnoughToEqual( a, b );                  &#x2F;&#x2F; true </span><br></pre></td></tr></table></figure><h3 id="整数检测"><a href="#整数检测" class="headerlink" title="整数检测"></a>整数检测</h3><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger( 42 );     &#x2F;&#x2F; true</span><br><span class="line">Number.isInteger( 42.000 ); &#x2F;&#x2F; true </span><br><span class="line">Number.isInteger( 42.3 );   &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    &#x2F;&#x2F; true</span><br><span class="line">Number.isSafeInteger( Math.pow( 2, 53 ) );          &#x2F;&#x2F; false </span><br><span class="line">Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );      &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><h3 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h3><ol><li>undefined 类型只有一个值，即 undefined。undefined 指没有值</li><li>null 类型也只有一个值，即 null。它们的名 称既是类型也是值。null 指空值</li><li>undefined 和 null 常被用来表示“空的”值或“不是值”的值</li><li>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。但是永远不要重新定义 undefined。</li></ol><h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>undefined 是一个内置标识符（除非被重新定义），它的值为 undefined， 通过 void 运算符即可得到该值</p><p>表达式 void ___ 没有返回值，因此返回结果是 undefined。按惯例我们用 void 0 来获得 undefined，void 并不改变表达式的结果， 只是让表达式不返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42; </span><br><span class="line">console.log( void a, a ); &#x2F;&#x2F; undefined 42</span><br></pre></td></tr></table></figure><h3 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h3><ol><li><h4 id="不是数字的数字"><a href="#不是数字的数字" class="headerlink" title="不是数字的数字"></a>不是数字的数字</h4></li></ol><p>如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字）， 就无法返回一个有效的数字，这种情况下返回值为 NaN。</p><p>NaN 意指“不是一个数字”（not a number），这个名字容易引起误会。NaN是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误 情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2 &#x2F; &quot;foo&quot;;      &#x2F;&#x2F; NaN </span><br><span class="line">typeof a &#x3D;&#x3D;&#x3D; &quot;number&quot;;  &#x2F;&#x2F; true   NaN仍然是数字类型</span><br></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reﬂexive，即 x === x 不 成立）的值。而 NaN != NaN 为 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2 &#x2F; &quot;foo&quot;; </span><br><span class="line">a &#x3D;&#x3D; NaN;   &#x2F;&#x2F; false</span><br><span class="line">a &#x3D;&#x3D;&#x3D; NaN;  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>可以使用内建的全局工具函数 isNaN(..) 来判断一个值是否是 NaN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2 &#x2F; &quot;foo&quot;; </span><br><span class="line">isNaN( a ); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>isNaN(..) 有一个严重的缺陷，它的检查方式过于死板，就 是“检查参数是否不是 NaN，也不是数字”。但是这样做的结果并不太准确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; &quot;foo&quot;; </span><br><span class="line">window.isNaN( b ); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>解决这个问题可以使用ES6工具函数 Number.isNaN(..)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Number.isNaN(..)实现原理</span><br><span class="line">return (typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp;  window.isNaN( n ));   </span><br></pre></td></tr></table></figure><p>还有一个方法是利用 NaN 不等于自身这个特点。NaN 是 JavaScript 中唯 一一个不等于自身的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!Number.isNaN) &#123;    </span><br><span class="line">    Number.isNaN &#x3D; function(n) &#123;     </span><br><span class="line">        return n !&#x3D;&#x3D; n;   </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><h4 id="无穷数"><a href="#无穷数" class="headerlink" title="无穷数"></a>无穷数</h4></li></ol><p>JavaScript 使用有限数字表示法，所以和纯粹的数学运算不同，JavaScript 的运算结果有可能溢出，此时结果为 Infinity 或者 -Infinity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1 &#x2F; 0;  &#x2F;&#x2F; Infinity</span><br><span class="line">var b &#x3D; -1 &#x2F; 0; &#x2F;&#x2F; -Infinity</span><br></pre></td></tr></table></figure><p>计算结果一旦溢出为无穷数（inﬁnity）就无法再得到有穷数</p><p>Infinity/ Infinity 是一个未定义操作，结果为 NaN。有穷正数除以 Infinity，结果是 0。</p><ol><li><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4></li></ol><p>JavaScript 有一个常规的 0（也叫作 +0）和一个 -0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 0 &#x2F; -3; &#x2F;&#x2F; -0 </span><br><span class="line">var b &#x3D; 0 * -3; &#x2F;&#x2F; -0   加法和减法运算不会得到负</span><br></pre></td></tr></table></figure><p>对负零进行字符串化会返回 “0”，如果反过来将其从字符串转换为数字，得到的结果是准确的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 0 &#x2F; -3; </span><br><span class="line">a + &quot;&quot;;          &#x2F;&#x2F; &quot;0&quot; </span><br><span class="line">+&quot;-0&quot;;           &#x2F;&#x2F; -0 </span><br><span class="line">&#x2F;&#x2F;JSON.stringify(-0) 返回 &quot;0&quot;，而 JSON.parse(&quot;-0&quot;) 返回 -0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-0 &#x3D;&#x3D; 0;    &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;区分-0和0的原理</span><br><span class="line"> n &#x3D; Number( n );     </span><br><span class="line"> return (n &#x3D;&#x3D;&#x3D; 0) &amp;&amp; (1 &#x2F; n &#x3D;&#x3D;&#x3D; -Infinity); </span><br></pre></td></tr></table></figure><p><strong>为什么要-0</strong></p><p>有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位 （sign）用来代表其他信息（比如移动的方向）。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p><h2 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h2><ol><li><p>简单值（即标量基本类型值，scalar primitive）总是通过<strong>值复制</strong>的方式来赋值 / 传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2; </span><br><span class="line">var b &#x3D; a; &#x2F;&#x2F; b是a的值的一个副本</span><br><span class="line">b++;</span><br><span class="line">a; &#x2F;&#x2F; 2</span><br><span class="line">b; &#x2F;&#x2F; 3 </span><br></pre></td></tr></table></figure></li><li><p>复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过<strong>引用复制</strong>的方式来赋值 / 传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; [1,2,3];</span><br><span class="line">var d &#x3D; c; &#x2F;&#x2F; d是[1,2,3]的一个引用 d.push( 4 );</span><br><span class="line">c; &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">d; &#x2F;&#x2F; [1,2,3,4]</span><br></pre></td></tr></table></figure><p>由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3]; </span><br><span class="line">var b &#x3D; a; </span><br><span class="line">b &#x3D; [4,5,6];</span><br><span class="line">a; &#x2F;&#x2F; [1,2,3]</span><br><span class="line">b; &#x2F;&#x2F; [4,5,6]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数传参时不能通过引用 x 来更改引用 a 的指向，只能更改 a 和 x 共同指向的值。</span><br><span class="line">function foo(x) &#123; </span><br><span class="line">    x.push( 4 );   </span><br><span class="line">    x; &#x2F;&#x2F; [1,2,3,4] </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 然后   </span><br><span class="line">    x &#x3D; [4,5,6];  </span><br><span class="line">    x.push( 7 );  </span><br><span class="line">    x; &#x2F;&#x2F; [4,5,6,7]</span><br><span class="line">    &#125; </span><br><span class="line">var a &#x3D; [1,2,3]; </span><br><span class="line">foo( a ); </span><br><span class="line"></span><br><span class="line">a; &#x2F;&#x2F; 是[1,2,3,4]，不是 [4,5,6,7]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传递的是指向数字对象的引用复本，但我们并不能通过它来更改其 中的基本类型值,原因是标量基本类型值是不可更改的，除非创建一个包含新值的数字对象。</span><br><span class="line">function foo(x) &#123;  </span><br><span class="line">    x &#x3D; x + 1;     </span><br><span class="line">    x; &#x2F;&#x2F; 3  </span><br><span class="line">    &#125; </span><br><span class="line"> var a &#x3D; 2; </span><br><span class="line"> var b &#x3D; new Number( a ); &#x2F;&#x2F; Object(a)也一样 </span><br><span class="line"> foo( b ); console.log( b ); &#x2F;&#x2F; 是2，不是 3</span><br></pre></td></tr></table></figure></li></ol><p>我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。如果想要改变传递的类型，有以下两种方法</p><ol><li>如果通过值复制的方式来传递复合值（如数组），就需要为其创建一个复本可利用slice()返回一个浅副本，这样传递的 就不再是原始值。</li><li>相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（对象、数组等）中，然后通过引用复制的方式传递。</li></ol><h1 id="3-原始函数"><a href="#3-原始函数" class="headerlink" title="3.原始函数"></a>3.原始函数</h1><blockquote><ol><li>JavaScript 为基本数据类型值提供了封装对象，称为原生函数（如 String、Number、Boolean 等）。它们为基本数据类型值提供了该子类型所特有的方法和属性（如：String#trim() 和 Array#concat(..)）。</li><li>对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实 现对这些属性和方法的访问。</li></ol></blockquote><p><strong>常用的原生函数有：</strong></p><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object()</li><li>Function()</li><li>RegExp()</li><li>Date()</li><li>Error()</li><li>Symbol()——ES6 中新加入的！<br>实际上，它们就是<strong>内建函数</strong>。</li></ul><h2 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h2><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( [1,2,3] ); &#x2F;&#x2F; &quot;[object Array]&quot; </span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call( &#x2F;regex-literal&#x2F;i ); &#x2F;&#x2F; &quot;[object RegExp]</span><br></pre></td></tr></table></figure><h2 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h2><p><strong>封装对象</strong>（object wrapper）扮演着十分重要的角色。由于基本类型值没有.length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 <strong>JavaScript 会自动为基本类型值包装一个封装对象</strong></p><p>一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什 么时候应该使用封装对象</p><h2 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h2><ol><li>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new String( &quot;abc&quot; ); </span><br><span class="line">a.valueOf(); &#x2F;&#x2F; &quot;abc&quot; </span><br></pre></td></tr></table></figure><ol><li>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。（即强制类型转换）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new String( &quot;abc&quot; );</span><br><span class="line">var b &#x3D; a + &quot;&quot;; &#x2F;&#x2F; b的值为&quot;abc&quot; </span><br></pre></td></tr></table></figure><h1 id="4-强制类型转换"><a href="#4-强制类型转换" class="headerlink" title="4.强制类型转换"></a>4.强制类型转换</h1><blockquote><ol><li>JavaScript 的数据类型之间的转换，即强制类型转换：包括显式和隐式。</li><li>强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的 JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。</li><li>显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维 护性。</li><li>隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转 换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。</li><li>在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知 其然，还要知其所以然，并努力让代码清晰易读。</li></ol></blockquote><h2 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h2><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐 式的情况称为强制类型转换（coercion）。JavaScript 中的强制类型转换总是返回标量基本类型值</p><h2 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。</p><p>基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。数字的字符串化则遵循通用规则，不过极小和极大的数字使用指数形式</p><p>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回 内部属性 [[Class]] 的值，如 “[object Object]”。</p><p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起 来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3]; </span><br><span class="line">a.toString(); &#x2F;&#x2F; &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure><p>工具函数 JSON.stringify(..)</p><p>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</p><p>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符 串化前调用，以便将对象转换为安全的 JSON 值。</p><h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>将非数字值当作数字来使用，其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number( &quot;&quot; );               &#x2F;&#x2F; 0 </span><br><span class="line">Number( [] );               &#x2F;&#x2F; 0 </span><br><span class="line">Number( [ &quot;abc&quot; ] );        &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><ol><li><h4 id="假值"><a href="#假值" class="headerlink" title="假值"></a>假值</h4></li><li><p>undefined</p></li><li><p>null</p></li><li><p>false</p></li><li><p>+0、-0</p></li><li><p>NaN</p></li><li><p>“”</p></li></ol><p>假值列表以 外的值都是真值</p><ol><li><h4 id="假值对象"><a href="#假值对象" class="headerlink" title="假值对象"></a>假值对象</h4></li></ol><p>document.all</p><ol><li><h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4></li></ol><p>真值就是假值列表之外的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;false&quot;; </span><br><span class="line">var b &#x3D; &quot;0&quot;; </span><br><span class="line">var c &#x3D; &quot;&#39;&#39;&quot;; </span><br><span class="line">var d &#x3D; Boolean( a &amp;&amp; b &amp;&amp; c ); </span><br><span class="line">d;&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];             &#x2F;&#x2F; 空数组——是真值还是假值？ </span><br><span class="line">var b &#x3D; &#123;&#125;;             &#x2F;&#x2F; 空对象——是真值还是假值？</span><br><span class="line">var c &#x3D; function()&#123;&#125;;   &#x2F;&#x2F; 空函数——是真值还是假值？ </span><br><span class="line">var d &#x3D; Boolean( a &amp;&amp; b &amp;&amp; c ); </span><br><span class="line">d;&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>真值列表可以无限长，无法一一列举，所以我们只能用假值列表作为参考</p><h2 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h2><h3 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h3><ol><li>String(..) 遵循前面讲过的 ToString 规则，将值转换为字符串基本类型。</li><li>Number(..) 遵循 前面讲过的 ToNumber 规则，将值转换为数字基本类型。</li><li>一元运算符 - 和 + 会将操作 数显式强制类型转换为数字</li></ol><h4 id="日期显式转换为数字"><a href="#日期显式转换为数字" class="headerlink" title="日期显式转换为数字"></a>日期显式转换为数字</h4><p>一元运算符 + 的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为 Unix 时间戳，以微秒为单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp &#x3D; +new Date();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp &#x3D; new Date().getTime(); </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp &#x3D; Date.now();</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="~ 运算符"></a>~ 运算符</h4><p>~ 运算符（即字位操作“非”）</p><p>~ 返回 2 的补码，所以~x 大致等同于 -(x+1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~42;    &#x2F;&#x2F; -(42+1) &#x3D;&#x3D;&gt; -43</span><br></pre></td></tr></table></figure><p>~ 和 indexOf() 一起可以将结果强制类型转换（实际 上仅仅是转换）为真 / 假值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;Hello World&quot;; </span><br><span class="line">if (a.indexOf( &quot;lo&quot; ) &gt;&#x3D; 0) &#123;   &#x2F;&#x2F; true     &#x2F;&#x2F; 找到匹配！ &#125; </span><br><span class="line">if (a.indexOf( &quot;ol&quot; ) &#x3D;&#x3D; -1) &#123;  &#x2F;&#x2F; true     &#x2F;&#x2F; 没有找到匹配！ &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#x3D; 0 和 &#x3D;&#x3D; -1 这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实 现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;Hello World&quot;; </span><br><span class="line">~a.indexOf( &quot;lo&quot; );         &#x2F;&#x2F; -4   &lt;-- 真值! </span><br><span class="line">if (~a.indexOf( &quot;lo&quot; )) &#123;   &#x2F;&#x2F; true     &#x2F;&#x2F; 找到匹配！ &#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( &quot;ol&quot; );         &#x2F;&#x2F; 0    &lt;-- 假值! </span><br><span class="line">!~a.indexOf( &quot;ol&quot; );        &#x2F;&#x2F; true </span><br><span class="line">if (!~a.indexOf( &quot;ol&quot; )) &#123;  &#x2F;&#x2F; true     &#x2F;&#x2F; 没有找到匹配！ &#125;</span><br></pre></td></tr></table></figure><p>如果 indexOf(..) 返回 -1，~ 将其转换为假值 0，其他情况一律转换为真值。</p><h3 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h3><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停 止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; &quot;42px&quot;; </span><br><span class="line">parseInt( b );  &#x2F;&#x2F; 42</span><br><span class="line"></span><br><span class="line">parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是 没有用的，比如 true、function()&#123;...&#125; 和 [1,2,3]。</span><br></pre></td></tr></table></figure><h3 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h3><ol><li>Boolean(..) 是显式的，但并不常用</li><li>显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值</li><li>一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将 真值反转为假值（或者将假值反转为真值）</li></ol><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><h3 id="字符串和数字之间的隐式强制类型转换"><a href="#字符串和数字之间的隐式强制类型转换" class="headerlink" title="字符串和数字之间的隐式强制类型转换"></a>字符串和数字之间的隐式强制类型转换</h3><ol><li><strong>数字强制类型转换为字符串</strong></li></ol><p>如果 + 的其中一个操作数是字符串， 则执行字符串拼接；否则执行数字加法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42; </span><br><span class="line">var b &#x3D; a + &quot;&quot;; </span><br><span class="line"></span><br><span class="line">b; &#x2F;&#x2F; &quot;42&quot;</span><br></pre></td></tr></table></figure><p>a + “”（隐式）和前面的String(a)（显式）之间有一个细微的差别需要注意。根据 ToPrimitive 抽象操作规则，a + “” 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象 操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;   </span><br><span class="line">    valueOf: function() &#123; return 42; &#125;,  </span><br><span class="line">    toString: function() &#123; return 4; &#125; &#125;; </span><br><span class="line"> a + &quot;&quot;;         &#x2F;&#x2F; &quot;42&quot; </span><br><span class="line">String( a );    &#x2F;&#x2F; &quot;4&quot;</span><br></pre></td></tr></table></figure><ol><li><strong>字符串强制类型转换为数字的情况</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;3.14&quot;; </span><br><span class="line">var b &#x3D; a - 0; </span><br><span class="line">b; &#x2F;&#x2F; 3.14</span><br><span class="line"></span><br><span class="line">- 是数字减法运算符，因此 a - 0 会将 a 强制类型转换为数字。也可以使用 a * 1 和 a &#x2F; 1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。</span><br></pre></td></tr></table></figure><p>对象的 - 操作与 + 类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [3];</span><br><span class="line">var b &#x3D; [1]; </span><br><span class="line">a - b; &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">为了执行减法运算，a 和 b 都需要被转换为数字，它们首先被转换为字符串（通过强制类型转换toString()），然后再转换为数字。</span><br></pre></td></tr></table></figure><h3 id="隐式强制类型转换为布尔值"><a href="#隐式强制类型转换为布尔值" class="headerlink" title="隐式强制类型转换为布尔值"></a>隐式强制类型转换为布尔值</h3><ul><li>if (..) 语句中的条件判断表达式。</li><li>for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</li><li>while (..) 和 do..while(..) 循环中的条件判断表达式。</li><li>? : 中的条件判断表达式。</li><li>逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</li></ul><h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h3><p>在JavaScript 中的表现也和在其他语言中不太一样，“逻辑运算符”，因为这不太准确。称它们为“选择器运算符”更恰当。它们的返回值是两个操作数中的一个（且仅一个）。即<strong>选择两个操作数中的一个，然后返回它的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42; </span><br><span class="line">var b &#x3D; &quot;abc&quot;;</span><br><span class="line">var c &#x3D; null; </span><br><span class="line">a || b;     &#x2F;&#x2F; 42  </span><br><span class="line">a &amp;&amp; b;     &#x2F;&#x2F; &quot;abc&quot; </span><br><span class="line"></span><br><span class="line">c || b;     &#x2F;&#x2F; &quot;abc&quot;  </span><br><span class="line">c &amp;&amp; b;     &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><ol><li>对于|| 来说，如果条件判断结果为true 就返回第一个操作数（a 和 c）的值，如果为 false 就返回第二个操作数（b）的值。应用赋予默认值</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数（b）的值，如果为 false 就返 回第一个操作数（a 和 c）的值。应用守护运算符</li></ol><h3 id="符号的强制类型转换"><a href="#符号的强制类型转换" class="headerlink" title="符号的强制类型转换"></a>符号的强制类型转换</h3><p>ES6 允许 从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s1 &#x3D; Symbol( &quot;cool&quot; ); </span><br><span class="line">String( s1 );     &#x2F;&#x2F; &quot;Symbol(cool)&quot; </span><br><span class="line"></span><br><span class="line">var s2 &#x3D; Symbol( &quot;not cool&quot; );</span><br><span class="line">s2 + &quot;&quot;;      &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure><h2 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h2><ul><li>“== 检查值是否相等，=== 检查值和类型是否相等” 说法不准确</li><li>正确的解释是：“**== 允许在相等比较中进行强制类型转换，而 === 不允许**。”</li><li>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就<br>用 ===，不用在乎性能。</li><li><strong>== 和 === 都会检查操作数的类型</strong>。区别在于操作数类型不同时它们的处理方式不同。</li></ul><h3 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h3><ol><li>如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，”abc” 等于 “abc”。</li><li>两个对象指向同一个值时 即视为相等，不发生强制类型转换。</li><li>== 在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之 一或两者都转换为相同的类型后再进行比较。</li></ol><h4 id="字符串和数字之间的相等比较"><a href="#字符串和数字之间的相等比较" class="headerlink" title="字符串和数字之间的相等比较"></a>字符串和数字之间的相等比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 42;</span><br><span class="line">var b &#x3D; &quot;42&quot;; </span><br><span class="line">a &#x3D;&#x3D;&#x3D; b;    &#x2F;&#x2F; false </span><br><span class="line">a &#x3D;&#x3D; b;     &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">因为没有强制类型转换，所以 a &#x3D;&#x3D;&#x3D; b 为 false，42 和 &quot;42&quot; 不相等。</span><br><span class="line">而 a &#x3D;&#x3D; b 是宽松相等，即如果两个值的类型不同，则对其中之一或两者都进行强制类型 转换。</span><br></pre></td></tr></table></figure><blockquote><p>(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。</p><p>(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</p></blockquote><h4 id="其他类型和布尔类型之间的相等比较"><a href="#其他类型和布尔类型之间的相等比较" class="headerlink" title="其他类型和布尔类型之间的相等比较"></a>其他类型和布尔类型之间的相等比较</h4><p>== 最容易出错的一个地方是 true 和 false 与其他类型之间的相等比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;42&quot;;</span><br><span class="line">var b &#x3D; true; </span><br><span class="line">a &#x3D;&#x3D; b; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">将 true 强制类型转换为 1，变成 1 &#x3D;&#x3D; &quot;42&quot;，二者的 类型仍然不同，&quot;42&quot; 根据规则被强制类型转换为 42，最后变成 1 &#x3D;&#x3D; 42，结果为 false。反过来也一样</span><br></pre></td></tr></table></figure><blockquote><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</p><p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p></blockquote><p>建议：无论什么情况下都不要使用 == true 和 == false。请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换可以使用</p><h4 id="null-和-undefined-之间的相等比较"><a href="#null-和-undefined-之间的相等比较" class="headerlink" title="null 和 undefined 之间的相等比较"></a>null 和 undefined 之间的相等比较</h4><blockquote><p>(1) 如果 x 为 null，y 为 undefined，则结果为 true。</p><p>(2) 如果 x 为 undefined，y 为 null，则结果为 true。</p></blockquote><p>在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种 情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; null; </span><br><span class="line">var b;</span><br><span class="line">a &#x3D;&#x3D; b;     &#x2F;&#x2F; true</span><br><span class="line">a &#x3D;&#x3D; false; &#x2F;&#x2F; false</span><br><span class="line">b &#x3D;&#x3D; false; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>null 和 undefined 之间的强制类型转换是安全可靠的，通过这种方式将 null 和 undefined 作为等价值来处理比较好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; doSomething(); </span><br><span class="line">if (a &#x3D;&#x3D; null) &#123;     &#x2F;&#x2F; .. &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; doSomething(); </span><br><span class="line">if (a &#x3D;&#x3D;&#x3D; undefined || a &#x3D;&#x3D;&#x3D; null) &#123;     &#x2F;&#x2F; .. &#125;</span><br></pre></td></tr></table></figure><h4 id="对象和非对象之间的相等比较"><a href="#对象和非对象之间的相等比较" class="headerlink" title="对象和非对象之间的相等比较"></a>对象和非对象之间的相等比较</h4><blockquote><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；</p><p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &quot;abc&quot;; </span><br><span class="line">var b &#x3D; Object( a );    &#x2F;&#x2F; 和new String( a )一样 </span><br><span class="line"></span><br><span class="line">a &#x3D;&#x3D;&#x3D; b;                &#x2F;&#x2F; false</span><br><span class="line">a &#x3D;&#x3D; b;                 &#x2F;&#x2F; true</span><br><span class="line">因为 b 通过 ToPromitive 进行强制类型转换（也称为“拆封”），并返回标量基本类型值 &quot;abc&quot;，与 a 相等。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; null; </span><br><span class="line">var b &#x3D; Object( a );    &#x2F;&#x2F; 和Object()一样</span><br><span class="line">a &#x3D;&#x3D; b;                 &#x2F;&#x2F; false </span><br><span class="line">var c &#x3D; undefined;      </span><br><span class="line">var d &#x3D; Object( c );    &#x2F;&#x2F; 和Object()一样 </span><br><span class="line">c &#x3D;&#x3D; d;                &#x2F;&#x2F; false </span><br><span class="line">var e &#x3D; NaN;            </span><br><span class="line">var f &#x3D; Object( e );    &#x2F;&#x2F; 和new Number( e )一样 </span><br><span class="line">e &#x3D;&#x3D; f;                 &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">因为没有对应的封装对象，所以 null 和 undefined 不能够被封装（boxed）， Object(null) 和 Object() 均返回一个常规对象。</span><br><span class="line">NaN 能够被封装为数字封装对象，但拆封之后 NaN &#x3D;&#x3D; NaN 返回 false，因为 NaN 不等于 NaN </span><br></pre></td></tr></table></figure><h3 id="比较少见的情况"><a href="#比较少见的情况" class="headerlink" title="比较少见的情况"></a>比较少见的情况</h3><h4 id="返回其他数字"><a href="#返回其他数字" class="headerlink" title="返回其他数字"></a>返回其他数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.prototype.valueOf &#x3D; function() &#123;     return 3; &#125;; </span><br><span class="line">new Number( 2 ) &#x3D;&#x3D; 3;   &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Number(2) 涉及 ToPrimitive 强制类型 转换，因此会调用 valueOf()。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;     &#x2F;&#x2F; .. &#125;</span><br></pre></td></tr></table></figure><h4 id="假值的相等比较"><a href="#假值的相等比较" class="headerlink" title="假值的相等比较"></a>假值的相等比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;0&quot; &#x3D;&#x3D; false;          &#x2F;&#x2F; true</span><br><span class="line">false &#x3D;&#x3D; 0;            &#x2F;&#x2F; true </span><br><span class="line">false &#x3D;&#x3D; &quot;&quot;;           &#x2F;&#x2F; true </span><br><span class="line">false &#x3D;&#x3D; [];           &#x2F;&#x2F; true</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; 0;               &#x2F;&#x2F; true </span><br><span class="line">&quot;&quot; &#x3D;&#x3D; [];              &#x2F;&#x2F; true </span><br><span class="line">0 &#x3D;&#x3D; [];               &#x2F;&#x2F; true </span><br></pre></td></tr></table></figure><h4 id="极端情况"><a href="#极端情况" class="headerlink" title="极端情况"></a>极端情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] &#x3D;&#x3D; ![]   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &#x3D;&#x3D; [2];       &#x2F;&#x2F; true</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; [null];   &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">第一行中的 [2] 会转换为 &quot;2&quot;，然后通过 ToNumber 转换为 2。第二行中的 [null] 会直接转 换为 &quot;&quot;。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D;&#x3D; &quot;\n&quot;;  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">42 &#x3D;&#x3D; &quot;43&quot;;                        &#x2F;&#x2F; false </span><br><span class="line">&quot;foo&quot; &#x3D;&#x3D; 42;                       &#x2F;&#x2F; false </span><br><span class="line">&quot;true&quot; &#x3D;&#x3D; true;                    &#x2F;&#x2F; false </span><br><span class="line"></span><br><span class="line">42 &#x3D;&#x3D; &quot;42&quot;;                        &#x2F;&#x2F; true </span><br><span class="line">&quot;foo&quot; &#x3D;&#x3D; [ &quot;foo&quot; ];                &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot; &#x3D;&#x3D; 0;               &#x2F;&#x2F; true </span><br><span class="line">&quot;&quot; &#x3D;&#x3D; [];              &#x2F;&#x2F; true </span><br><span class="line">0 &#x3D;&#x3D; [];               &#x2F;&#x2F; true </span><br></pre></td></tr></table></figure><h4 id="安全运用隐式强制类型转换"><a href="#安全运用隐式强制类型转换" class="headerlink" title="安全运用隐式强制类型转换"></a>安全运用隐式强制类型转换</h4><p>我们要对 == 两边的值认真推敲，以下两个原则可以让我们有效地避免出错。这时最好用 === 来避免不经意的强制类型转换。</p><ol><li>如果两边的值中有 true 或者 false，千万不要使用 ==。</li><li>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</li></ol><h2 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h2><ol><li><p>比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [ 42 ]; </span><br><span class="line">var b &#x3D; [ &quot;43&quot; ]; </span><br><span class="line">a &lt; b;  &#x2F;&#x2F; true</span><br><span class="line">b &lt; a;  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li></ol><p>如果比较双方都是字符串，则按字母顺序来进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [ &quot;42&quot; ]; </span><br><span class="line">var b &#x3D; [ &quot;043&quot; ];  </span><br><span class="line">a &lt; b;  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; b: 42 &#125;; </span><br><span class="line">var b &#x3D; &#123; b: 43 &#125;; </span><br><span class="line">a &lt; b;  &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; b: 42 &#125;;</span><br><span class="line">var b &#x3D; &#123; b: 43 &#125;; </span><br><span class="line">a &lt; b;  &#x2F;&#x2F; false</span><br><span class="line">a &#x3D;&#x3D; b; &#x2F;&#x2F; false </span><br><span class="line">a &gt; b;  &#x2F;&#x2F; false </span><br><span class="line"></span><br><span class="line">a &lt;&#x3D; b; &#x2F;&#x2F; true</span><br><span class="line">a &gt;&#x3D; b; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">因为根据规范 a &lt;&#x3D; b 被处理为 b &lt; a，然后将结果反转。因为 b &lt; a 的结果是 false，所 以 a &lt;&#x3D; b 的结果是 true。</span><br><span class="line">实际上 JavaScript 中 &lt;&#x3D; 是 “不大于”的意思（即 !(a &gt; b)，处理为 !(b &lt; a)）。同理 a &gt;&#x3D; b 处理为 b &lt;&#x3D; a。</span><br></pre></td></tr></table></figure><p>相等比较有严格相等，关系比较却没有“严格关系比较”。 也就是说如果<strong>要避免 a &lt; b 中发生隐式强制类型转换，我们只能确保 a 和 b 为相同的类型</strong>， 除此之外别无他法</p><h1 id="5-语法"><a href="#5-语法" class="headerlink" title="5.语法"></a>5.语法</h1><blockquote><ol><li>JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。从长远来看，这有 助于更深入地掌握这门语言。</li><li>语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表 达式可以是简单独立的，否则可能会产生副作用。</li><li>JavaScript 语法规则之上是语义规则（也称作上下文）。例如，{ } 在不同情况下的意思不 尽相同，可以是语句块、对象常量、解构赋值（ES6）或者命名函数参数（ES6）。</li><li>JavaScript 详细定义了运算符的优先级（运算符执行的先后顺序）和关联（多个运算符的 组合方式）。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。</li><li>ASI（自动分号插入）是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的（可以省略）， 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。</li><li>JavaScript 中有很多错误类型，分为两大类：早期错误（编译时错误，无法被捕获）和运 行时错误（可以通过 try..catch 来捕获）。所有语法错误都是早期错误，程序有语法错误 则无法运行。</li><li>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们 挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。</li><li>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑， 特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌 弄巧成拙。</li><li>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是，如果对其理解得不够透 彻，稍不注意就很容易出错。</li></ol></blockquote><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="2021/03/26/Promise/"/>
      <url>2021/03/26/Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-执行机制"><a href="#JavaScript-执行机制" class="headerlink" title="JavaScript 执行机制"></a>JavaScript 执行机制</h2><hr><p>javascript是一门<strong>单线程</strong>语言不能同时处理多个任务，把任务分成了同步和异步。</p><h3 id="事件循环Event-Loop"><a href="#事件循环Event-Loop" class="headerlink" title="事件循环Event Loop"></a>事件循环Event Loop</h3><p>事件循环是js实现异步的一种方法，也是js的执行机制。</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;举个栗子</span><br><span class="line">let data &#x3D; [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;发送成功!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;代码执行结束&#39;);</span><br></pre></td></tr></table></figure><ol><li>ajax进入Event Table，注册回调函数<code>success</code>。</li><li>执行<code>console.log(&#39;代码执行结束&#39;)</code>。</li><li>ajax事件完成，回调函数<code>success</code>进入Event Queue。</li><li>主线程从Event Queue读取回调函数<code>success</code>并执行</li></ol><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);  &#x2F;&#x2F;4</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;promise&#39;); &#x2F;&#x2F;1</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;then&#39;);  &#x2F;&#x2F;3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#39;console&#39;);  &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure><ol><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>整体代码script作为第一个宏任务执行结束，执行<code>then</code>在微任务Event Queue里面。</li><li>第一轮事件循环结束了，开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li></ol><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><hr><p>Promise 可以理解为承诺，就像我们去点餐服务员给我们一引订单票，这就是承诺。如果餐做好了叫我们这就是成功，如果没有办法给我们做出食物这就是拒绝。</p><p>一个 <code>promise</code> 必须有一个 <code>then</code> 方法用于处理状态改变</p><h2 id="状态说明"><a href="#状态说明" class="headerlink" title="状态说明"></a>状态说明</h2><hr><p>Promise包含<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>三种状态</p><ol><li><code>pending</code> 指初始等待状态，初始化 <code>promise</code> 时的状态</li><li><code>resolve</code> 指已经解决，将 <code>promise</code> 状态设置为<code>fulfilled</code></li><li><code>reject</code> 指拒绝处理，将 <code>promise</code> 状态设置为<code>rejected</code></li></ol><p><code>promise</code> 是生产者，通过 <code>resolve</code> 与 <code>reject</code> 函数告之结果</p><p><code>promise</code> 非常适合需要一定执行时间的异步任务</p><p>状态一旦改变将不可更改</p><p>promise 是队列状态，就像体育中的接力赛，状态一直向后传递，当然其中的任何一个promise也可以改变状态。</p><ul><li><p>promise 没有使用 <code>resolve</code> 或 <code>reject</code> 更改状态时，状态为 <code>pending</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">    new Promise((resolve, reject) &#x3D;&gt; &#123;&#125;)</span><br><span class="line">)&#x2F;&#x2F;Promise&#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure></li><li><p>promise状态更改为resolve或reject之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">            new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">                resolve(&#39;felfilled&#39;)</span><br><span class="line">            &#125;)</span><br><span class="line">        ) &#x2F;&#x2F;Promise&#123;&lt;felfilled&gt;:felfilled&#125;</span><br><span class="line"></span><br><span class="line"> console.log(</span><br><span class="line">        new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            reject(&#39;rejected&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ); &#x2F;&#x2F;Promise&#123;&lt;rejected&gt;:rejected&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>promise</code> 创建时即立即执行即同步任务，<code>then</code> 会放在异步微任务中执行，需要等同步任务执行后才执行。</p></li><li><p><code>promise</code> 的 then、catch、finally的方法都是异步任务</p></li><li><p>程序需要将主任务执行完成才会执行异步队列任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;iamys.club&#39;);</span><br><span class="line">    console.log(&#39;世界&#39;);</span><br><span class="line">&#125;).then(msg &#x3D;&gt; &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;你好&#39;);</span><br><span class="line">&#x2F;&#x2F;世界</span><br><span class="line">&#x2F;&#x2F;你好</span><br><span class="line">&#x2F;&#x2F;iamys.club</span><br></pre></td></tr></table></figure><ul><li>Promise里的是微任务比回调函数的宏任务先执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">     setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">         console.log(&#39;定时器&#39;);</span><br><span class="line">     &#125;, 3000);</span><br><span class="line">     resolve(&quot;fulfilled&quot;);</span><br><span class="line"> &#125;).then(</span><br><span class="line">     msg &#x3D;&gt; &#123;</span><br><span class="line">         console.log(msg);</span><br><span class="line">     &#125;,</span><br><span class="line">     error &#x3D;&gt; &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">     &#125;</span><br><span class="line"> );</span><br><span class="line"> &#x2F;&#x2F;felfilled</span><br><span class="line"> &#x2F;&#x2F;定时器</span><br></pre></td></tr></table></figure></li><li><p>状态被改变后就不能再修改了。下面先通过<code>resolve</code> 改变为成功状态，表示<code>promise</code> 状态已经完成，就不能使用 <code>reject</code> 更改状态了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;操作成功&quot;);</span><br><span class="line">    reject(new Error(&quot;请求失败&quot;));</span><br><span class="line">&#125;).then(</span><br><span class="line">    msg &#x3D;&gt; &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;操作成功</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态改变"><a href="#动态改变" class="headerlink" title="动态改变"></a>动态改变</h2><hr><ul><li><p>如果 <code>resolve</code> 参数是一个 <code>promise</code> ，将会改变<code>promise</code>状态。</p><p>下例中 <code>p1</code> 的状态将被改变为 <code>p2</code> 的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(</span><br><span class="line">        &#x2F;&#x2F;p2</span><br><span class="line">        new Promise((s, e) &#x3D;&gt; &#123;</span><br><span class="line">            e(&quot;失败&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;).then(msg &#x3D;&gt; &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    reson &#x3D;&gt; &#123;</span><br><span class="line">        console.log(reson);&#x2F;&#x2F;失败</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>当promise做为参数传递时，需要等待promise执行完才可以继承</p><p>下面的p2需要等待p1执行完成。因为<code>p2</code> 的<code>resolve</code> 返回了 <code>p1</code> 的promise，所以此时<code>p2</code> 的<code>then</code> 方法已经是<code>p1</code> 的了，所以 <code>then</code> 的第一个函数输出了 <code>p1</code> 的 <code>resolve</code> 的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">           resolve(&quot;操作成功&quot;);</span><br><span class="line">       &#125;, 2000);</span><br><span class="line">   &#125;);</span><br><span class="line">   const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">       resolve(p1);</span><br><span class="line">   &#125;).then(</span><br><span class="line">       msg &#x3D;&gt; &#123;</span><br><span class="line">           console.log(msg);&#x2F;&#x2F;操作成功</span><br><span class="line">       &#125;,</span><br><span class="line">       error &#x3D;&gt; &#123;</span><br><span class="line">           console.log(error);</span><br><span class="line">       &#125;</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></li></ul><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><hr><p>一个promise 需要提供一个then方法访问promise 结果，<code>then</code> 用于定义当 <code>promise</code> 状态发生改变时的处理，即<code>promise</code>处理异步操作，<code>then</code> 用于结果。</p><ul><li>then 方法必须返回 promise，用户返回或系统自动返回</li><li>第一个函数在<code>resolved</code> 状态时执行，即执行<code>resolve</code>时执行<code>then</code>第一个函数处理成功状态，如果只关心失败时状态，<code>then</code> 的第一个参数传递 <code>null</code></li><li>第二个函数在<code>rejected</code>状态时执行，即执行<code>reject</code> 时执行第二个函数处理失败状态，该函数是可选的</li><li>两个函数都接收 <code>promise</code> 传出的值做为参数</li><li>也可以使用<code>catch</code> 来处理失败的状态，那就是对所有没有指定失败返回的统一的失败返回</li><li>如果 <code>then</code> 返回 <code>promise</code> ，下一个<code>then</code> 会在当前<code>promise</code> 状态改变后执行</li></ul><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><code>promise</code> 中的 <code>then</code> 方法可以链接执行，<code>then</code> 方法的返回值会传递到下一个<code>then</code> 方法。</p><ul><li><p><code>then</code> 会返回一个<code>promise</code> ，所以如果有多个<code>then</code> 时会连续执行</p></li><li><p><code>then</code> 返回的值会做为当前<code>promise</code> 的结果</p></li><li><p>第一个<code>then</code> 是对上个promise 的状态的处理，每个 <code>then</code> 会是一个新的promise，默认传递 <code>fulfilled</code>状态，上一个 promise状态不会影响以后then返回的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(</span><br><span class="line">        resolve &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">        reject &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        resolve &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">        reject &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        resolve &#x3D;&gt; console.log(&quot;fulfilled&quot;),</span><br><span class="line">        reject &#x3D;&gt; console.log(&quot;rejected&quot;)</span><br><span class="line">    );</span><br><span class="line">&#x2F;&#x2F; 执行结果如下</span><br><span class="line">&#x2F;&#x2F; rejected</span><br><span class="line">&#x2F;&#x2F; fulfilled</span><br><span class="line">&#x2F;&#x2F; fulfilled</span><br></pre></td></tr></table></figure></li><li><p>如果内部返回promise，就用这个promise</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; p1.then(() &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise(r &#x3D;&gt; &#123;</span><br><span class="line">        r(&quot;iamys.club&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(v &#x3D;&gt; &#123;</span><br><span class="line">    console.log(v); &#x2F;&#x2F;iamys.club</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如果 <code>then</code> 返回<code>promise</code> 时，后面的<code>then</code> 就是对返回的 <code>promise</code> 的处理（promise的返回值是promise也一样），其他操作需要等待该 promise 变更状态后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">let p1 &#x3D; promise.then(() &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;p1&#96;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((a, b) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#96;p2&#96;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;p1</span><br><span class="line">&#x2F;&#x2F;p2</span><br></pre></td></tr></table></figure></li><li><p>如果<code>then</code>返回 <code>promise</code> 时，返回的<code>promise</code> 后面的<code>then</code> 就是处理这个<code>promise</code> 的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(v &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&quot;第二个promise&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F;第二个promise</span><br><span class="line">  return value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F;第二个promise</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="其它类型"><a href="#其它类型" class="headerlink" title="其它类型"></a>其它类型</h3><ul><li><p>如果 <code>then</code> 返回与 <code>promise</code> 相同将禁止执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p2 &#x3D; promise.then(() &#x3D;&gt; &#123;</span><br><span class="line">  return p2;</span><br><span class="line">&#125;); &#x2F;&#x2F; TypeError: Chaining cycle detected for promise</span><br></pre></td></tr></table></figure></li><li><p>包含 <code>then</code> 方法的对象就是一个 <code>promise</code> ，享受和promise一样的特性和待遇，如果对象中的 then 不是函数，则将对象做为值传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        resolve(</span><br><span class="line">            class &#123;</span><br><span class="line">                static then(resolve, reject) &#123;</span><br><span class="line">                    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        resolve(&quot;解决状态&quot;);</span><br><span class="line">                    &#125;, 2000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;).then(</span><br><span class="line">        v &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;felfilled: $&#123;v&#125;&#96;);&#x2F;&#x2F;felfilled:解决状态</span><br><span class="line">        &#125;,</span><br><span class="line">        v &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;rejected: $&#123;v&#125;&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><hr><p>catch用于失败状态的处理函数，等同于 <code>then(null,reject)&#123;&#125;</code></p><ul><li><p>建议使用 <code>catch</code> 处理错误</p></li><li><p>将 <code>catch</code> 放在最后面用于统一处理前面发生的错误</p></li><li><p>错误是冒泡的操作的，只要一个<code>then</code> 没有定义第二个函数，将一直冒泡到 <code>catch</code> 处理错误</p></li><li><p><code>catch</code> 也可以捕获对 <code>then</code> 抛出的错误处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">         resolve();</span><br><span class="line">     &#125;)</span><br><span class="line">     .then(msg &#x3D;&gt; &#123;</span><br><span class="line">         throw new Error(&quot;这是then 抛出的错误&quot;);</span><br><span class="line">     &#125;)</span><br><span class="line">     .catch(() &#x3D;&gt; &#123;</span><br><span class="line">         console.log(&quot;33&quot;);&#x2F;&#x2F;33</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在异步中 <code>throw</code> 将不会触发 <code>catch</code>，而使用系统错误处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        throw new Error(&quot;fail&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;).catch(msg &#x3D;&gt; &#123;</span><br><span class="line">    console.log(msg + &quot;123&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="定制错误"><a href="#定制错误" class="headerlink" title="定制错误"></a>定制错误</h3><p>404错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class ParamError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name &#x3D; &quot;ParamError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HttpError extends Error &#123;</span><br><span class="line">  constructor(msg) &#123;</span><br><span class="line">    super(msg);</span><br><span class="line">    this.name &#x3D; &quot;HttpError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (!&#x2F;^http&#x2F;.test(url)) &#123;</span><br><span class="line">      throw new ParamError(&quot;请求地址格式错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload &#x3D; function() &#123;</span><br><span class="line">      if (this.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(JSON.parse(this.response));</span><br><span class="line">      &#125; else if (this.status &#x3D;&#x3D; 404) &#123;</span><br><span class="line">        reject(new HttpError(&quot;用户不存在&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(&quot;加载失败&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror &#x3D; function() &#123;</span><br><span class="line">      reject(this);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#96;url&#96;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  if (error instanceof ParamError) &#123;</span><br><span class="line">    console.log(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">  if (error instanceof HttpError) &#123;</span><br><span class="line">    alert(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><hr><p>无论状态是<code>resolve</code> 或 <code>reject</code> 都会执行此动作，<code>finally</code> 与状态无关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&quot;hdcms&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(msg &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(msg &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;reject&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;resolve&#x2F;reject状态都会执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h2><hr><ol><li><p>使用 <code>promise.resolve</code> 方法可以快速的返回一个<code>promise</code>对象</p></li><li><p>和 <code>Promise.resolve</code> 类似，<code>reject</code> 生成一个失败的<code>promise</code></p></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.all</span><br></pre></td></tr></table></figure><p>方法可以同时执行多个并行异步操作，比如页面加载时同进获取课程列表与推荐课程。</p><ul><li>任何一个 <code>Promise</code> 执行失败就会调用 <code>catch</code>方法</li><li>适用于一次发送多个异步操作</li><li>参数必须是可迭代类型，如Array/Set</li><li>成功后返回 <code>promise</code> 结果的有序数组</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const hdcms &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&quot;第一个Promise&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">const houdunren &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&quot;第二个异步&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">const hd &#x3D; Promise.all([hdcms, houdunren])</span><br><span class="line">    .then(results &#x3D;&gt; &#123;</span><br><span class="line">        console.log(results);</span><br><span class="line">    &#125;)  &#x2F;&#x2F;[&quot;第一个Promise&quot;, &quot;第二个异步&quot;]</span><br><span class="line">    .catch(msg &#x3D;&gt; &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol><li><p><code>allSettled</code> 用于处理多个<code>promise</code> ，只关注执行完成，不关注是否全部执行成功，<code>allSettled</code> 状态只会是<code>fulfilled</code>。</p></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race()</span><br></pre></td></tr></table></figure><p>处理容错异步，和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">race</span><br></pre></td></tr></table></figure><p>单词一样哪个Promise快用哪个，哪个先返回用哪个。</p><ul><li>以最快返回的promise为准</li><li>如果最快返加的状态为<code>rejected</code> 那整个<code>promise</code>为<code>rejected</code>执行cache</li><li>如果参数不是promise，内部将自动转为promise</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const hdcms &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&quot;第一个Promise&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">const houdunren &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&quot;第二个异步&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([hdcms, houdunren])</span><br><span class="line">    .then(results &#x3D;&gt; &#123;</span><br><span class="line">        console.log(results);&#x2F;&#x2F;第二个异步</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(msg &#x3D;&gt; &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><hr><p><code>async/await</code> 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。</p><ul><li><code>async/await</code> 本质还是promise，只是更简洁的语法糖书写</li><li><code>async/await</code> 使用更清晰的promise来替换 promise.then/catch 的方式</li></ul><ol><li><p>函数前加上async，函数将返回promise，我们就可以像使用标准Promise一样使用了。</p></li><li><p>如果有多个await 需要排队执行完成，我们可以很方便的处理多个异步队列</p><p>使用 <code>await</code> 关键词后会等待promise 完</p><ul><li><code>await</code> 后面一般是外部的promise，如果不是直接返回</li><li><code>await</code> 必须放在 async 定义的函数中使用</li><li><code>await</code> 用于替代 <code>then</code> 使编码更优雅</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function hd(message) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">          setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">              resolve(message);</span><br><span class="line">          &#125;, 2000);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  async function run() &#123;</span><br><span class="line">      let h1 &#x3D; await hd(&quot;好的&quot;);</span><br><span class="line">      console.log(h1);</span><br><span class="line">      let h2 &#x3D; await hd(&quot;123&quot;);</span><br><span class="line">      console.log(h2);</span><br><span class="line">  &#125;</span><br><span class="line">  run();</span><br></pre></td></tr></table></figure><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><p>有时需要多个await 同时执行，有以下几种方法处理，下面多个await 将产生等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">async function p1() &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;123&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function p2() &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;456&quot;);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function hd() &#123;</span><br><span class="line">  await p1();</span><br><span class="line">  await p2();</span><br><span class="line">&#125;</span><br><span class="line">hd();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;相当于使用 Promise.all() 处理多个promise并行执行</span><br><span class="line">async function hd() &#123;</span><br><span class="line">  await Promise.all([p1(), p2()]);</span><br><span class="line">&#125;</span><br><span class="line">hd();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="2021/03/26/vuex/"/>
      <url>2021/03/26/vuex/</url>
      
        <content type="html"><![CDATA[<p><code>Vuex</code>是一个全局数据管理的一种机制，可以方便的实现数据的共享</p><h4 id="使用Vuex管理数据的好处"><a href="#使用Vuex管理数据的好处" class="headerlink" title="使用Vuex管理数据的好处"></a>使用Vuex管理数据的好处</h4><p>A.能够在<code>vuex</code>中集中管理共享的数据，便于开发和后期进行维护<br>B.能够高效的实现组件之间的数据共享，提高开发效率<br>C.存储在<code>vuex</code>中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新</p><p>使用<code>Vuex</code>只需要在创建项目配置的时候选上<code>vuwx</code>即可，会自动生成以下页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>提供唯一的公共数据源，所有共享的数据都要统一放在<code>store</code>的<code>state</code>中存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">    user: JSON.parse(window.localStorage.getItem(&#39;user&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中访问<code>State</code>的方式：<br>1)<code>this.$store.state</code>.全局数据名称 ：<code>this.$store.state.count</code><br>2).先按需导入mapState函数：<code>import &#123; mapState &#125; from &#39;vuex&#39;</code><br>然后数据映射为计算属性：<code>computed:&#123; ...mapState([&#39;全局数据名称&#39;]) &#125;</code></p><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p>用于修改<code>$store</code>中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">       setUser(state, data) &#123;</span><br><span class="line">           &#x2F;&#x2F;第一个形参永远都是state也就是$state对象</span><br><span class="line">           &#x2F;&#x2F;第二个形参是调用setUser时传递的参数</span><br><span class="line">           state.user &#x3D; data</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F;为了数据持久化，把数据放在本地</span><br><span class="line">           window.localStorage.setItem(&#39;user&#39;, JSON.stringify(state.user))</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>在组件中访问<code>mutations</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用函数名，传递参数</span><br><span class="line"> this.$store.commit(&#39;setUser&#39;,data.data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class="line">methods:&#123;</span><br><span class="line">  ...mapMutations([&#39;add&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>在<code>mutations</code>中不能编写异步的代码，会导致<code>vue</code>调试器的显示出错。<br>在<code>vuex</code>中我们可以使用<code>Action</code>来执行异步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addAsync(context,step)&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">      context.commit(&#39;add&#39;,step);</span><br><span class="line">    &#125;,2000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中访问<code>action</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  AddAsync()&#123;</span><br><span class="line">    this.$store.dispatch(&#39;addAsync&#39;,5)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &#39;vuex&#39;</span><br><span class="line">methods:&#123;</span><br><span class="line">  ...mapMutations([&#39;subAsync&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p><code>getter</code>用于对<code>store</code>中的数据进行加工处理形成新的数据<br>它只会包装<code>store</code>中保存的数据，并不会修改<code>store</code>中保存的数据，当<code>store</code>中的数据发生变化时，<code>getter</code>生成的内容也会随之变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">  &#x2F;&#x2F;添加了一个showNum的属性</span><br><span class="line">  showNum : state &#x3D;&gt;&#123;</span><br><span class="line">    return &#39;最新的count值为：&#39;+state.count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中访问<code>getter</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;$store.getters.showNum&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#39;vuex&#39;</span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapGetters([&#39;showNum&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="2021/03/26/vue/"/>
      <url>2021/03/26/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%B9%E6%B3%95">数据与方法</a></h1><p>当一个 Vue 实例被创建时，它将 数据 对象中的所有的 属性加入到 Vue 的<strong>响应式系统</strong>中。当这些 属性 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。值得注意的是只有当实例被创建时就已经存在于数据中的属性才是<strong>响应式</strong>的。也就是说如果你添加一个新的属性，那么对于这个新添加的属性的改动不会触发任何试图的更新</p><p>使用 <code>Object.freeze()</code>，这会阻止修改现有的 属性，也意味着响应系统无法再<em>追踪</em>变化。</p><p>除了数据 属性，Vue 实例还暴露了一些有用的实例 属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的 属性 区分开来。<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">API 参考</a></p><h3 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">实例生命周期钩子</a></h3><ul><li>挂载（初始化相关属性）</li></ul><ol><li>beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用</li><li>created 在实例创建完成后立即被调用</li><li>beforeMount 在挂载开始之前被调用</li><li>mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子</li></ol><ul><li>更新（元素或组件的变更操作）</li></ul><ol><li>beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前</li><li>updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子</li></ol><ul><li>销毁（销毁相关属性）关属性）</li></ul><ol><li>beforeDestroy 实例销毁之前调用</li><li>destroyed 实例销毁之后调用</li></ol><p>不要在选项 property 或回调上使用箭头函数因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致错误</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%8F%92%E5%80%BC">插值</a></h4><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%96%87%E6%9C%AC">文本</a>：数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值</p><p><a href="https://cn.vuejs.org/v2/api/#v-once">v-once 指令</a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定</p><p><a href="https://cn.vuejs.org/v2/api/#v-html"><code>v-html</code> 指令</a>：双大括号会将数据解释为普通文本，而非 HTML 代码。v-html输出真正的 HTML（站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>）</p><p><a href="https://cn.vuejs.org/v2/api/#v-bind"><code>v-bind</code> 指令</a>：绑定html属性</p><p>对于以上所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong></p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4">指令</a></h3><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。</p><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。</p><p>v-bind可以绑定动态参数，你可以使用动态参数为一个动态的事件名绑定处理函数</p><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a></h4><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定</p><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99"><code>v-bind</code> 缩写</a>为<code>:</code>,<a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99"><code>v-on</code> 缩写</a>为<code>@</code></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a></h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以将同一函数定义为一个方法(methods)而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。</p><p>观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 <code>watch</code>,通常更好的做法是使用计算属性而不是命令式的 <code>watch</code> 回调</p><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">侦听器</a></h3><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 <code>watch</code> 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch">vm.$watch API</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
